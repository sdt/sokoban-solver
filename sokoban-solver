#!/usr/bin/env perl
use 5.16.0;
use warnings;
use autodie;
use Function::Parameters qw(:strict);
use List::Util qw( max );
use Time::HiRes qw( usleep );
use Term::ANSIColor qw( colored );
use warnings FATAL => 'all';

# Sokoban solver
#
# Level files look like so: .
      ###
      #.#
  #####.#####
 ##         ##
##  # # # #  ##
#  ##     ##  #
# ##  # #  ## #
#     $@$     #
####  ###  ####
   #### ####

my $wall = '#';
my $hole = '.';
my $rock = '$';
my $dude = '@';
my $floor = ' ';
my $sleep_us = 200_000;
my $states = 0;

my %moves = (
    U => [ 0, -1 ],
    D => [ 0, +1 ],
    L => [ -1, 0 ],
    R => [ +1, 0 ],
);

my %colors = (
    $dude => 'magenta',
    $hole => 'blue',
    $rock => 'yellow',
);
exit main(@ARGV);

fun main(@argv) {
    my ($board, $state) = parse_level($argv[0] // 'test.txt');
    my $solution = solve_level($board, $state);
    playback_solution($board, $state, $solution) if $solution;
    say $solution // 'No solution';
    say "$states states examined";
    return 0;
}

# Game configuration is:
# board + player(x,y) + @rocks[x,y] + @holes[x,y]
#
# Solution = @holes == 0 (or @rocks == 0)
#
# Move options:
#   @_  -> _@
#   @.  -> _@
#   @$_ -> _@$
#   @$. -> _@_
# Everything else means no move
#
# Another board config is:
#   image + player(x,y) + score
# Solution = score == 0
# Score drops on @$. -> _@_
#
# Another option: $object{$x:$y} = player | rock | wall | hole

fun solve_level($board, $state) {
    my @agenda = ( [ $state, '' ] );

    my $seen_states = {};
    while (my $next = shift(@agenda)) {
        my ($state, $hist) = @$next;
        $states++;
        for my $move (keys %moves) {
            my ($dx, $dy) = @{ $moves{$move} };
            my $new_state = try_move($board, $state, $dx, $dy);
            next unless $new_state;
            next if has_been_seen($new_state, $seen_states);
            my $new_hist = "$hist,$move";
            return substr($new_hist, 1) if is_solution($new_state);
            push(@agenda, [ $new_state, $new_hist ]);
        }
    }
    return;
}

fun print_state($board, $state) {
    for my $y (0 .. $board->{h}-1) {
        my $row;
        for my $x (0 .. $board->{w}-1) {
            my $c = ($x == $state->{x} && $y == $state->{y}) ?
                    $dude : lookup($board, $state, key($x, $y));
            $row .= colorise($c);
        }
        say $row;
    }
}

fun colorise($char) {
    my $color = $colors{$char};
    return $color ? colored($char, $color) : $char;
}

fun playback_solution($board, $state, $solution) {
    print_state($board, $state);

    for my $move (split(/,/, $solution)) {
        my ($dx, $dy) = @{ $moves{$move} };
        $state = try_move($board, $state, $dx, $dy);
        usleep($sleep_us);
        say '';
        print_state($board, $state);
    }
}

fun parse_level($filename) {
    open my $fh, '<', $filename;
    my $board = { };
    my $state = { };
    my $pos;
    my $y = 0;
    my $w = 0;
    for my $line (<$fh>) {
        my $x = 0;
        for my $char (split(//, $line)) {
            my $key = key($x, $y);
            if ($char eq $dude) {
                $state->{x} = $x;
                $state->{y} = $y;
            }
            elsif ($char eq $hole || $char eq $rock) { $state->{$key} = $char }
            elsif ($char eq $wall) { $board->{$key} = $char }
            $x++;
            $w = max($w, $x);
        }
        $y++;
    }
    $board->{w} = $w;
    $board->{h} = $y;
    my $holes = grep { $_ eq $hole } values %$state;
    my $rocks = grep { $_ eq $rock } values %$state;
    die "$rocks rocks, but $holes holes" unless $holes == $rocks;
    die "No rocks or holes!" unless $holes;

    return ($board, $state);
}

fun state_rep($state) {
    my @keys = sort keys %$state;
    join('', map { $_ => $state->{$_} } @keys);
}

fun is_solution($state) {
    (grep { $_ eq $rock } values %$state) == 0
}

fun try_move($board, $state, $dx, $dy) {
    my $x = $state->{x};
    my $y = $state->{y};

    my $p0key = key($x + $dx, $y + $dy);
    my $p0 = lookup($board, $state, $p0key);
    if ($p0 eq $floor || $p0 eq $hole) {
        return new_state($state, { x => $x + $dx, y => $y + $dy });
    }
    elsif ($p0 eq $rock) {
        my $p1key = key($x + $dx * 2, $y + $dy * 2);
        my $p1 = lookup($board, $state, $p1key);
        if ($p1 eq $floor) {
            return new_state($state,
                { x => $x + $dx, y => $y + $dy, $p1key => $rock }, [ $p0key ]);
        }
        elsif ($p1 eq $hole) {
            return new_state($state,
                { x => $x + $dx, y => $y + $dy }, [ $p0key, $p1key ]);
        }
    }
    return;
}

fun lookup($board, $state, $key) {
    return $board->{$key} // $state->{$key} // $floor;
}

fun new_state($state, $changes, $deletions = []) {
    my %new_state = ( %$state, %$changes );
    delete @new_state{@$deletions};
    return \%new_state;
}

fun has_been_seen($state, $history) {
    my $rep = state_rep($state);
    return $history->{$rep}++;
}

fun key($x, $y) { "$x:$y" }
fun unkey($key) { split(/:/, $key) }
