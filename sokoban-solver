#!/usr/bin/env perl
use 5.16.0;
use warnings;
use autodie;
use Function::Parameters qw(:strict);
use List::Util qw( max );
use Time::HiRes qw( usleep );
use Term::ANSIColor qw( colored );
use warnings FATAL => 'all';

# Sokoban solver
#
# Level files look like so: .
      ###
      #.#
  #####.#####
 ##         ##
##  # # # #  ##
#  ##     ##  #
# ##  # #  ## #
#     $@$     #
####  ###  ####
   #### ####

my $wall = '#';
my $hole = '.';
my $rock = '$';
my $dude = '@';
my $floor = ' ';

my $sleep_us = 100_000;
my $states = 0;

my $green = 'G';
my $red   = 'R';

my %moves = (
    U => [ 0, -1 ],
    D => [ 0, +1 ],
    L => [ -1, 0 ],
    R => [ +1, 0 ],
);

my %colors = (
    $dude  => 'magenta',
    $hole  => 'blue',
    $rock  => 'yellow',
    $red   => 'red',
    $green => 'cyan',
);

my %colormap;

exit main(@ARGV);

fun main(@argv) {
    my ($board, $state) = parse_level($argv[0] // 'test.txt');
    my $solution = solve_level($board, $state);
    if ($solution) {
        playback_solution($board, $state, $solution);
        say $solution;
    }
    else {
        say STDERR 'No solution';
    }
    say STDERR "$states states examined";
    return 0;
}

# Game configuration is:
# board + player(x,y) + @rocks[x,y] + @holes[x,y]
#
# Solution = @holes == 0 (or @rocks == 0)
#
# Move options:
#   @_  -> _@
#   @.  -> _@
#   @$_ -> _@$
#   @$. -> _@_
# Everything else means no move
#
# Another board config is:
#   image + player(x,y) + score
# Solution = score == 0
# Score drops on @$. -> _@_
#
# Another option: $object{$x:$y} = player | rock | wall | hole

fun solve_level($board, $state) {
    my @agenda = ( [ $state, '' ] );

    my $seen_states = {};
    while (my $next = shift(@agenda)) {
        my ($state, $hist) = @$next;
        say STDERR "$states states, ", scalar @agenda, " in queue, $hist"
            if ((++$states & 0x7FFF) == 0);
        for my $move (keys %moves) {
            my ($dx, $dy) = @{ $moves{$move} };
            my $new_state = try_move($board, $state, $dx, $dy);
            next unless $new_state;
            next if has_been_seen($new_state, $seen_states);
            my $new_hist = "$hist,$move";
            return substr($new_hist, 1) if is_solution($new_state);
            push(@agenda, [ $new_state, $new_hist ]);
        }
    }
    return;
}

fun print_state($board, $state) {
    for my $y (0 .. $board->{h}-1) {
        my $row;
        for my $x (0 .. $board->{w}-1) {
            my $c = ($x == $state->{x} && $y == $state->{y}) ?
                    $dude : lookup($board, $state, key($x, $y));
            $row .= colorise($c);
        }
        say STDERR $row;
    }
}

fun print_colormap($board, $state, $colormap) {
    for my $y (0 .. $board->{h}-1) {
        my $row;
        for my $x (0 .. $board->{w}-1) {
            my $key = key($x, $y);
            my $c = $state->{$key} // $colormap->{$key} // $floor;
            $row .= colorise($c);
        }
        say STDERR $row;
    }
}

fun colorise($char) {
    my $color = $colors{$char};
    return $color ? colored($char, $color) : $char;
}

fun playback_solution($board, $state, $solution) {
    print_state($board, $state);

    for my $move (split(/,/, $solution)) {
        my ($dx, $dy) = @{ $moves{$move} };
        $state = try_move($board, $state, $dx, $dy);
        usleep($sleep_us);
        say '';
        print_state($board, $state);
    }
}

fun parse_level($filename) {
    open my $fh, '<', $filename;
    my $board = { };
    my $state = { };
    my $pos;
    my $y = 0;
    my $w = 0;
    for my $line (<$fh>) {
        my $x = 0;
        for my $char (split(//, $line)) {
            my $key = key($x, $y);
            if ($char eq $dude) {
                $state->{x} = $x;
                $state->{y} = $y;
            }
            elsif ($char eq $hole || $char eq $rock) { $state->{$key} = $char }
            elsif ($char eq $wall) { $board->{$key} = $char }
            $x++;
            $w = max($w, $x);
        }
        $y++;
    }
    $board->{w} = $w;
    $board->{h} = $y;
    my $holes = grep { $_ eq $hole } values %$state;
    my $rocks = grep { $_ eq $rock } values %$state;
    die "$rocks rocks, but $holes holes" unless $holes == $rocks;
    die "No rocks or holes!" unless $holes;

    return ($board, $state);
}

fun state_rep($state) {
    my @keys = sort keys %$state;
    join('', map { $_ => $state->{$_} } @keys);
}

fun holes_rep($state) {
    my @keys = sort grep { $state->{$_} eq $hole } keys %$state;
    join(',', @keys);
}

fun is_solution($state) {
    (grep { $_ eq $rock } values %$state) == 0
}

fun try_move($board, $state, $dx, $dy) {
    my $x = $state->{x};
    my $y = $state->{y};

    my $colormap = colormap($board, $state);

    my $p0key = key($x + $dx, $y + $dy);
    my $p0 = lookup($board, $state, $p0key);
    if ($p0 eq $floor || $p0 eq $hole) {
        return new_state($state, { x => $x + $dx, y => $y + $dy });
    }
    elsif ($p0 eq $rock) {
        my $p1key = key($x + $dx * 2, $y + $dy * 2);
        my $p1 = lookup($board, $state, $p1key);
        if ($p1 eq $floor && $colormap->{$p1key} ne $red) {
            return new_state($state,
                { x => $x + $dx, y => $y + $dy, $p1key => $rock }, [ $p0key ]);
        }
        elsif ($p1 eq $hole) {
            return new_state($state,
                { x => $x + $dx, y => $y + $dy }, [ $p0key, $p1key ]);
        }
    }
    return;
}

fun lookup($board, $state, $key) {
    return $board->{$key} // $state->{$key} // $floor;
}

fun new_state($state, $changes, $deletions = []) {
    my %new_state = ( %$state, %$changes );
    delete @new_state{@$deletions};
    return \%new_state;
}

fun has_been_seen($state, $history) {
    my $rep = state_rep($state);
    return $history->{$rep}++;
}

fun key($x, $y) { "$x:$y" }
fun unkey($key) { split(/:/, $key) }

fun make_colormap($board, $state) {
    my $w = $board->{w};
    my $h = $board->{h};
    my $colormap = {};

    # First of all, holes are always green
    for my $key (grep { $state->{$_} eq $hole } keys %$state) {
        $colormap->{$key} = $green;
    }

    # And walls are red
    for my $key (grep { $_ =~ /^\d+:\d+$/ } keys %$board) {
        $colormap->{$key} = $red;
    }

    # Floodfill from the edges - the outside area is red
    # (or green it doesn't matter really)
    for my $x (0 .. $w-1) {
        floodfill($board, $colormap, $x, 0, $red);
        floodfill($board, $colormap, $x, $h - 1, $red);
    }
    for my $y (0 .. $h-1) {
        floodfill($board, $colormap, 0, $y, $red);
        floodfill($board, $colormap, $w - 1, $y, $red);
    }

    my $board_size = $w * $h;
    my $colors_filled = keys %$colormap;
    while (keys %$colormap < $board_size) {

        # For each green square, find any neighbouring squares that could be
        # pushed onto this green square, and colour them green also.
        for my $key (grep { $colormap->{$_} eq $green } keys %$colormap) {
            my ($x, $y) = unkey($key);
            for my $delta (values %moves) {
                my ($dx, $dy) = @$delta;
                my ($x0, $y0) = ($x + $dx, $y + $dy);
                my $key0 = key($x0, $y0);
                next if $colormap->{$key0};
                my ($x1, $y1) = ($x0 + $dx, $y0 + $dy);
                my $key1 = key($x1, $y1);
                next if $board->{$key1};
                $colormap->{$key0} = $green;
            }
        }
        my $prev = $colors_filled;
        $colors_filled = keys %$colormap;
        last if $prev == $colors_filled;
    }

    # Any remaining squares are now red
    for my $y (0 .. $h-1) {
        for my $x (0 .. $w-1) {
            $colormap->{key($x, $y)} //= $red;
        }
    }

    return $colormap;
}

fun floodfill($board, $colormap, $x, $y, $c) {
    return if ($x < 0 || $x >= $board->{w});
    return if ($y < 0 || $y >= $board->{h});
    my $key = key($x, $y);
    return if $board->{$key};
    return if $colormap->{$key};
    $colormap->{$key} = $c;
    for my $delta (values %moves) {
        my ($dx, $dy) = @$delta;
        floodfill($board, $colormap, $x + $dx, $y + $dy, $c);
    }
}

fun colormap($board, $state) {
    my $state_rep = holes_rep($state);
    return $colormap{$state_rep} //= make_colormap($board, $state);
}
